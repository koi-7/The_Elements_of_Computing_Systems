# 10章 コンパイラ#1：構文解析

出力用のファイル名と比較用のファイル名が同じなので比較用のファイルを退避もしくは改名しておく

```
$ rename 's/.xml/_orig.xml/' *.xml
```

## 第1段階：トークナイザ

xxxT.xml を出力するプログラムは JackAnalizer_forPhase1.py、JackTokenizer_forPhase1.py とし、第2段階のパーサとは別のプログラムとして書いた。

### 方針

1. 1行読んでコメントもしくは API コメントの途中なら何もせずに次の行へ
2. 読み込んだソースコードの1行からトークンリストを作成する
3. トークンリストを pop し各要素がどのトークンタイプかを見て xml ファイルを記述していく

### make_token_list メソッド

トークンリストを生成するにあたってテキストに記載されている API の他に make_token_list メソッドを追加した。このメソッドは今読まれているソースコードの一行から各トークンを要素としたリストを返す。

  - 例：```if (x < 153)``` → ```['if', '(', 'x', '&lt;', '153', ')']```

この実装はソースコードの一行を一文字ずつ解析することで実現した。

### トークンリストの作り方について

Jack プログラムの中で "（ダブルクォーテーション）で囲まれた部分はプログラマが文字列を自由に記述できるので、コード一行を一文字ずつ読んで解析する方法では工夫が必要となる。

そこで、make_token_list メソッドではダブルクォーテーションの解析は対象外とし、その代わりにメソッドにコード一行を渡す前にダブルクォーテーションについての解析を行った。

例えば ArrayTest/Main.jack の15行目にはダブルクォーテーションが含まれたソースコードが記述されている。

```
let length = Keyboard.readInt("HOW MANY NUMBERS? ");
```

ここでまず Python のダブルクォーテーションを区切りとした split 関数を用いてリスト（list をする）を作成する。このとき元々あったダブルクォーテーションも再度加えておく。

```
## list
['let length = Keyboard.readInt(', '"HOW MANY NUMBERS? "', ');']
```

次に list[0] と list[2] を make_token_list メソッドに渡せばトークンのリストが返されるのであとは適宜それらをつなぎ合わせればよい。

```
token_list = make_token_list(list[0]) + [list[1]] + make_token_list(list[2])
```

これで以下のリストが完成する。

```
# token_list
['let', 'length', '=', 'Keyboard', '.', 'readInt', '(', '"HOW MANY NUMBERS? "', ')', ';']
```

## 第2段階：パーサ

- シンタックスエラーなし
  - hasMoreTokens() の意味が薄れる気がする
- write_xml() 説明
